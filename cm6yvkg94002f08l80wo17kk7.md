---
title: "[JS] 불변성(Immutability)"
seoTitle: "자바스크립트 불변성"
datePublished: Mon Feb 10 2025 09:52:56 GMT+0000 (Coordinated Universal Time)
cuid: cm6yvkg94002f08l80wo17kk7
slug: js-immutability
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1739186591017/69f08c8c-2f81-4188-9c0b-e5087e40b843.png
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1739180691789/e8b9f25a-ffc2-4144-bc2b-bce7d59de03a.png
tags: immutability, 67ai67oa7isx

---

## **📌 불변성**

자바스크립트에서 불변성이란 "한 번 만든 값은 바꿀 수 없고, 변경은 기존 값 자체를 변경하는 것이 아니라, 새로운 메모리 공간을 만들어 새로운 값을 저장하고, 변수가 이를 가리키도록 하는 방식이 불변성이다.

**📌 불변값(Immutable) vs 가변값(Mutable)의 차이**

📍 **불변값(Immutable Value)** → 값을 변경할 때마다 **새로운 메모리 공간을 할당**하여 변경

📍 **가변값(Mutable Value)** → 기존 메모리 공간을 유지한 채 **값을 직접 수정 가능**

여기서 말하는 불변성이 기준은 **"변수"가 아니라 "데이터 자체"가 변경될 수 있는가이다.**

즉 불변성을 구분할 때의 변경 가능성의 대상의 **데이터 영역 메모리**이다.

자바스크립트의 메모리 구조는 크게 "변수 영역"과 "데이터 영역"으로 나뉜다.

---

### **📌 기본형 데이터 (Primitive Type)**

📍 **기본형 데이터(**`string`, `number` 등)는 불변(Immutable) 하며, 새로운 값을 할당하면 **새로운 메모리 공간**이 생성된다.

```jsx
let str;         // 변수 str 선언
str = "Hello";   // 변수 str에 데이터 할당
str = "hello";   // 새로운 문자열 할당
console.log(str);  // "hello"
```

### **🛠 메모리 변화 과정**

### **1️⃣** `let str;` (변수 선언)

```plaintext
📌 변수 영역:
┌────1003───┐
│ str:      │  
└───────────┘
```

* 메모리에서 비어있는 공간을 확보하고 그 공간의 이름을 설정하는 선언 과정
    

---

### **2️⃣** `str = "Hello";` (값 할당)

```plaintext
📌 변수 영역:                 📌 데이터 영역:
┌────1003───┐                 ┌──────────────┐
│ str: 5001  │ →             │ 5001: "Hello" │
└───────────┘                 └──────────────┘
```

* `"Hello"`라는 문자열이 Heap에 저장되고, `str`은 그 주소(`5001`)를 참조.
    

---

### **3️⃣** `str = "hello";` (새로운 값 할당)

```plaintext
📌 변수 영역:                 📌 데이터 영역:
┌────1003───┐                 ┌──────────────┐
│ str: 6001  │ →             │ 5001: "Hello" │  (GC 대상)
└───────────┘                │ 6001: "hello" │
                              └──────────────┘
```

* 기본형 데이터는 **불변**이므로, 기존 값을 변경하지 않고 **새로운 값을 생성하여 새로운 메모리 공간(6001)에 저장**한다.
    
* `"Hello"`는 더 이상 사용되지 않으면 GC(Garbage Collector)의 대상이 됨.
    

→ **기본형 데이터는 기존 값을 변경하는 것이 아니라, 새로운 값을 생성하고 변수가 이를 가리키도록 함.**

---

### **📌 참조형 데이터 (Reference Type)**

📍 **참조형 데이터(**`object`, `array`, `function` 등)는 가변(Mutable) 하며, 기본형 데이터와의 차이는 ‘객체의 변수(프로퍼티) 영역’이 별도로 존재한다는 점이다.

```jsx
let obj1 = { name: "Alice", age: 25 };
let obj2 = obj1;
obj2.name = "Bob";
```

### **🛠 메모리 변화 과정**

### **1️⃣** `let obj1 = { name: "Alice", age: 25 };` (객체 생성)

```plaintext
📌 변수 영역:             📌 데이터 영역:                📌 객체의 변수(프로퍼티) 영역:
┌─────1003─────┐         ┌───────────────────────┐        ┌───────────────────┐
│ obj1: 5001   │  →     │ 5001: 6001~6002        │  →    │ 6001[name:"Alice"] │
└──────────────┘         │                       │       │ 6002[age:25]       │
                         └───────────────────────┘        └───────────────────┘
```

* `obj1`은 Stack에서 **Heap에 저장된 객체(5001)의 주소를 참조**한다.
    
* `name`과 `age` 속성은 **별도의 Heap 주소(6001, 6002)를 가리킨다.**(📌 **이것이 객체의 변수(프로퍼티) 영역!**)
    

---

### **2️⃣** `obj2 = obj1;` (새로운 변수에 참조값 할당)

```plaintext
📌 변수 영역:             📌 데이터 영역:                📌 객체의 변수(프로퍼티) 영역:
┌─────1003─────┐         ┌───────────────────────┐        ┌───────────────────┐
│ obj1: 5001   │  →     │ 5001: 6001,6002        │  →    │ 6001[name:"Alice"] │
│ obj2: 5001   │  →      │                       │       │ 6002[age:25]       │
└──────────────┘         └───────────────────────┘        └───────────────────┘
```

* `obj2`는 새로운 객체를 생성하는 것이 아니라, `obj1`과 같은 **객체(5001)의 주소를 참조**함.
    
* 따라서, `obj1`과 `obj2`는 **같은 객체를 가리킴.**
    

---

### **3️⃣** [`obj2.name`](http://obj2.name) `= "Bob";` (객체 속성 변경)

```plaintext
📌 변수 영역:            📌 데이터 영역:                  📌 객체의 변수(프로퍼티) 영역:
┌─────1003─────┐         ┌───────────────────────┐        ┌───────────────────┐
│ obj1: 5001   │  →     │ 5001: 7001,6002        │  →    │ 6001[name:"Alice"] │ (GC)
│ obj2: 5001   │  →      │                       │       │ 6002[age:25]       │
└──────────────┘         └───────────────────────┘       │ 7001[name:"Bob"]   │
                                                          └───────────────────┘
```

* **객체의** `name` 프로퍼티가 "Alice"에서 "Bob"으로 변경됨.
    
* 이 변경은 **변수 영역이 아니라, 데이터 영역(5001)에서 이루어짐.**
    

→ **객체의 프로퍼티를 변경하면 데이터 영역이 수정되므로, 참조형 데이터는 가변적이다!**

---

### **📌 불변 객체**

**참조형 데이터가 가변적이다라고 말하는 것은, 내부 프로퍼티를 변경할 때를 말합니다.**

즉 데이터 자체를 변경하려고 하면(새로운 데이터를 할당하고자하면) 기본형과 마찬가지로 기존 데이터는 변하지 않습니다.

```jsx
const obj1 = { name: "Alice", age: 25 };
const obj2 = obj1;  // 같은 객체를 참조

obj2 = { name: "Bob", age: 30 };  // 새로운 객체 할당 (재할당)

console.log(obj1.name); // "Alice" (원본 유지)
console.log(obj2.name); // "Bob" (새로운 객체)
```

### **📌 왜 불변 객체가 중요한가?**

✅ **데이터의 예측 가능성을 유지하기 위해**

* 객체가 가변적이면, 하나의 변수가 변경될 때 **같은 객체를 참조하는 다른 변수들도 영향을 받는다.**
    

✅ **상태 관리에서 필수**

* 리액트와 같은 UI 프레임워크에서는 상태(state)가 변경될 때 UI가 리렌더링됨.
    
* 만약 객체를 직접 변경하면 변경 감지가 어려워지고, UI가 예상대로 동작하지 않을 수 있음.**.**
    

즉 데이터의 예측 가능성을 위해 불변성을 유지하는것은 중요하다

따라서, 이런 문제를 방지하려면 기존 객체를 직접 수정하지 않고 새로운 객체를 생성하는 방식(불변 객체 유지)이 필요하다.

그렇다면 **불변 객체를 만들려면 어떻게 해야할까?**

다음 포스팅을 기대해주세요🚀