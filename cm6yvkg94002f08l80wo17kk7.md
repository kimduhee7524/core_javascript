---
title: "[JS] 불변성(Immutability)"
seoTitle: "자바스크립트 불변성"
datePublished: Mon Feb 10 2025 09:52:56 GMT+0000 (Coordinated Universal Time)
cuid: cm6yvkg94002f08l80wo17kk7
slug: js-immutability
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1739186591017/69f08c8c-2f81-4188-9c0b-e5087e40b843.png
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1739180691789/e8b9f25a-ffc2-4144-bc2b-bce7d59de03a.png
tags: immutability, 67ai67oa7isx

---

## **📌 불변성**

자바스크립트에서 불변성을 구분하는 기준은

**데이터가 변경될 때 "전체가 새로운 메모리에 할당되는가?" 또는 "일부만 새로운 메모리에 할당되는가?"**

✔ **데이터 전체가 새로운 메모리에 할당되면 불변(Immutable), 일부만 변경되면 가변(Mutable)**

즉 불변성을 구분하는 기준은 **"변수"가 아니라 "데이터 자체"가 변경될 수 있는가이다.**

자바스크립트의 메모리 구조는 크게 "변수 영역"과 "데이터 영역"으로 나뉜다.

---

### **📌 기본형 데이터 (Primitive Type)**

📍 **기본형 데이터(**`string`, `number` 등)는 불변(Immutable) 하며, 새로운 값을 할당하면 **새로운 메모리 공간**이 생성된다.

```jsx
let str;         // 변수 str 선언
str = "Hello";   // 변수 str에 데이터 할당
str = "hello";   // 새로운 문자열 할당
console.log(str);  // "hello"
```

### **🛠 메모리 변화 과정**

### **1️⃣** `let str;` (변수 선언)

```plaintext
📌 변수 영역:
┌────1003───┐
│ str:      │  
└───────────┘
```

* 메모리에서 비어있는 공간을 확보하고 그 공간의 이름을 설정하는 선언 과정
    

---

### **2️⃣** `str = "Hello";` (값 할당)

```plaintext
📌 변수 영역:                 📌 데이터 영역:
┌────1003───┐                 ┌──────────────┐
│ str: 5001  │ →             │ 5001: "Hello" │
└───────────┘                 └──────────────┘
```

* `"Hello"`라는 문자열이 Heap에 저장되고, `str`은 그 주소(`5001`)를 참조.
    

---

### **3️⃣** `str = "hello";` (새로운 값 할당)

```plaintext
📌 변수 영역:                 📌 데이터 영역:
┌────1003───┐                 ┌──────────────┐
│ str: 6001  │ →             │ 5001: "Hello" │  (GC 대상)
└───────────┘                │ 6001: "hello" │
                              └──────────────┘
```

* 기본형 데이터는 **불변**이므로, 기존 값을 변경하지 않고 **새로운 값을 생성하여 새로운 메모리 공간(6001)에 저장**한다.
    
* `"Hello"`는 더 이상 사용되지 않으면 GC(Garbage Collector)의 대상이 됨.
    

→ **기본형 데이터는 기존 값을 변경하는 것이 아니라, 새로운 값을 생성하고 변수가 이를 가리키도록 함.**

---

### **📌 참조형 데이터 (Reference Type)**

📍 **참조형 데이터(**`object`, `array`, `function` 등)는 가변(Mutable) 하며, 기본형 데이터와의 차이는 ‘객체의 변수(프로퍼티) 영역’이 별도로 존재한다는 점이다.

```jsx
let obj1 = { name: "Alice", age: 25 };
let obj2 = obj1;
obj2.name = "Bob";
```

### **🛠 메모리 변화 과정**

### **1️⃣** `let obj1 = { name: "Alice", age: 25 };` (객체 생성)

```plaintext
📌 변수 영역:             📌 데이터 영역:                📌 객체의 변수(프로퍼티) 영역:
┌─────1003─────┐         ┌─────────5001─────────┐       ┌───────7001───────┐
│ obj1: @5001  │  →      │ @7001,@7002          │  →    │ name: @5003      │
└──────────────┘         └──────────────────────┘       └──────────────────┘
                         ┌─────────5003─────────┐       ┌───────7002───────┐
                         │ "Alice"              │       │ age: @5004       │
                         └──────────────────────┘       └──────────────────┘
                         ┌─────────5004─────────┐       
                         │  25                  │     
                         └──────────────────────┘
```

---

### **2️⃣** `obj2 = obj1;` (새로운 변수에 참조값 할당)

```plaintext
📌 변수 영역:             📌 데이터 영역:                📌 객체의 변수(프로퍼티) 영역:
┌─────1003─────┐         ┌─────────5001─────────┐       ┌───────7001───────┐
│ obj1: @5001  │  →      │ @7001,@7002          │  →    │ name: @5003      │
│ obj2: @5001  │  →      └──────────────────────┘       └──────────────────┘
└──────────────┘         ┌─────────5003─────────┐       ┌───────7002───────┐
                         │ "Alice"              │       │ age: @5004       │
                         └──────────────────────┘       └──────────────────┘
                         ┌─────────5004─────────┐       
                         │  25                  │     
                         └──────────────────────┘
```

---

### **3️⃣** [`obj2.name`](http://obj2.name) `= "Bob";` (객체 속성 변경)

```plaintext
📌 변수 영역:             📌 데이터 영역:                 📌 객체의 변수(프로퍼티) 영역:
┌─────1003─────┐         ┌─────────5001─────────┐        ┌───────7001───────┐
│ obj1: @5001  │  →      │ @7001,@7002          │  →     │ name: @5005      │
│ obj2: @5001  │  →      └──────────────────────┘        └──────────────────┘
└──────────────┘         ┌─────────5003─────────┐        ┌───────7002───────┐
                         │ "Alice"              │(GC)    │ age: @5004       │
                         └──────────────────────┘        └──────────────────┘
                         ┌─────────5004─────────┐       
                         │  25                  │       
                         └──────────────────────┘        
                         ┌─────────5005─────────┐        
                         │  "Bob"               │         
                         └──────────────────────┘         
```

---

### **📌 불변 객체**

**참조형 데이터가 가변적이다라고 말하는 것은, 내부 프로퍼티를 변경할 때를 말합니다.**

즉 데이터 자체를 변경하려고 하면(새로운 데이터를 할당하고자하면) 기본형과 마찬가지로 기존 데이터는 변하지 않습니다.

```jsx
const obj1 = { name: "Alice", age: 25 };
const obj2 = obj1;  // 같은 객체를 참조

obj2 = { name: "Bob", age: 30 };  // 새로운 객체 할당 (재할당)

console.log(obj1.name); // "Alice" (원본 유지)
console.log(obj2.name); // "Bob" (새로운 객체)
```

### **📌 왜 불변 객체가 중요한가?**

✅ **데이터의 예측 가능성을 유지하기 위해**

* 객체가 가변적이면, 하나의 변수가 변경될 때 **같은 객체를 참조하는 다른 변수들도 영향을 받는다.**
    

✅ **상태 관리에서 필수**

* 리액트와 같은 UI 프레임워크에서는 상태(state)가 변경될 때 UI가 리렌더링됨.
    
* 만약 객체를 직접 변경하면 변경 감지가 어려워지고, UI가 예상대로 동작하지 않을 수 있음.**.**
    

즉 데이터의 예측 가능성을 위해 불변성을 유지하는것은 중요하다

따라서, 이런 문제를 방지하려면 기존 객체를 직접 수정하지 않고 새로운 객체를 생성하는 방식(불변 객체 유지)이 필요하다.

그렇다면 **불변 객체를 만들려면 어떻게 해야할까?**

다음 포스팅을 기대해주세요🚀